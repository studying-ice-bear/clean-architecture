# === 3부 설계원칙 ===

## 7장 SRP: 단일 책임 원칙
---
**하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.**
#### SRP원칙을 위반하는 징후
- 우발적 중복
  - 하나의 메서드가 하나의 메서드를 의존하지 않고 두개 이상의 메서드에 의존
  - 서로 다른 액터가 의존하는 코드를 너무 가까이 배치 한 것
- 병합
  - 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우
  - 서로 다른 액터를 뒷받침하는 코드를 분리 하지 않음
#### 해결책
1. 데이터와 메서드를 분리하는 방식
각 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다
이러한 단점은 퍼사드 방식으로 회피 할 수 있다
2. 퍼사드 방식
각 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체를 위임하는 일을 만드는 클래스를 앞단에 배치

## 8장 OCP: 개방-폐쇄 원칙
---
**소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**
#### 목표
- 시스템의 확장을 용이하게
  - 시스템을 컴포넌트 단위로 분리
- 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록록
  - 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조 설계

## 9장 LSP: 리스코프 치환 원칙
---
**부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야 한다**
#### 목표
- 상속
  - 애플리케이션의 행위가 하위타입을 의존하지 않을 수 있다.
- if문 으로 부터의 격리
  - 하위타입으로 분리하여 치환하는 것은 쓸데 없는 if문으로 부터의 격리가 가능

## 10장 ISP: 인터페이스 분리 원칙
---
**인터페이스를 사용에 맞게 끔 각기 분리해야한다**
#### 목표
- 사용에 맞게 인터페이스를 분리
  - 만약 인터페이스의 추상 메서드들을 범용적으로 이것저것 구현한다면, 그 인터페이스를 상속받은 클래스는 자신이 사용하지 않는 인터페이스마저 억지로 구현 해야 하는 상황이 올 수도 있다.
- ISP와 언어
  - 정적 타입 언어에서는 소스 코드의 include 등의 선언문으로 인해 의존성이 발생한다.
  - 하지만, 동적언어 에서는 이러한 선언문이 존재하지 않는다.

## 11장 DIP: 의존성 역전 원칙
---
**의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템**
#### 목표
- 추상적인 선언만을 참조
  - 정적언어의 use, import, include와 같은 구문은 오직 인터페이스나 추상클래스같은 추상적인 선언만을 참조 해야 함.
- 비현실적?
  - java.lang.String 구체 클래스 등 구현체에 의존하는 경우는 반드시 생김
  - 하지만, 이러한 구현체는 엄격하게 통제 됨
- 현실적인 방안
  - 안정성이 보장된 환경에 대해서는 무시하는 편 (변경이 되지 않는다면 의존할 수 있다)
  - 변동성이 큰 구체적인 요소(개발 하고있는 기능,소스 등)에 해당

## 문제, 공유하면 좋은 내용, 인상깊은점, 이해 안가는 부분

1. LSP의 치환 원칙을 쓰면 설계에 어떠한 장점 이 있는지? (다형성 ?)
2. 사용에 맞게 인터페이스를 분리 하는 것이 좋다, 분리해야 하는 기준은? (메서드?? 함수?? 기능??)
