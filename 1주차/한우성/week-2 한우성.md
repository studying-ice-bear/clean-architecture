# === 2부 벽돌부터 시작하기:프로그래밍 패러다임 ===

## 3장 패러다임 개요

세 가지 패러다임인 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍
- 구조적 프로그래밍
  - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다 (if/then/else/do/while/until)
- 객체 지향 프로그래밍
  - 제어흐름의 간접적인 전환에 대해 규칙을 부과한다 (클래스, 인스턴스 변수, 메서드)
- 함수형 프로그래밍
  - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다 (람다)

- 생각할 거리
  - 각 패러다임은 개발자에게 권한을 박탈한다 (goto문, 함수포인터, 할당문)
  - 즉, 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.

## 4장 구조적 프로그래밍

모든 프로그램은 설령 단순할지라도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다
 - 증명이라는 수학적인 원리로 이 문제를 해결하기 위해 접근
   - 유클리드 계층구조
   - 모든 프로그램은 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있다

테스트
 - 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다
 - 테스트는 틀림을 증명하지만, 맞다고 증명 할 수는 없다
 - 테스트는 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것 정도

결론
 - 구조적 프로그래밍의 가치는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력　

## 5장 객체지향 프로그래밍

캡슐화
 - 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다
 - 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다
 - 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 함
 => 객체지향 언어는 더 나은 캡슐화를 제공하지는 않았다

상속
 - 객체지향 언어에서는 업캐스팅이 암무적으로 이뤄진다
 - 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공
 => 객체지향 언어는 조금 더 나은 상속을 제공한다

다형성
 - 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점이다
 - 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용하게 해준다
 => 객체지향 언어는 제어흐름을 간접적으로 전환하는 규칙을 부과한다

의존성 역전
 - 소스 코드 사이에 인터페이스를 추가 함으로써 의존을 역전시킬 수 있다
 - 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다
 - 저수준의 세부사항을 포함하는 고수준 모듈에 대해 독립성을 보장 할 수 있다
 => 배포 독립성과, 개발 독립성을 갖게 된다

결론 
 - 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 흭득 할 수있는 능력

## 6장 함수형 프로그래밍

함수형 언어에서 변수는 변경되지 않는다
 - 변수가 변경되지 않으면, 경합조건, 교착상태조건, 동시업데이트 문제가 발생하지 않는다
 
가변성의 분리
 - 불변성의 타협 중 하나는 가변 컴포넌트와, 불변컴포넌트를 분리하는 것

이벤트 소싱
 - 상태나 변경이 아닌, 트랜젝션 그 자체를 저장 하는 것
 - 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리
 - 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.
